è¿™æ˜¯ä¸€ä¸ªéå¸¸ç¬¦åˆå·¥ç¨‹åŒ–è½åœ°çš„éœ€æ±‚ã€‚å°†åºå¤§çš„ JSON æ‹†åˆ†ä¸ºæ¨¡å—åŒ–çš„ YAML æ–‡ä»¶ï¼Œä¸ä»…æé«˜äº†**å¯è¯»æ€§**ï¼ˆæ”¯æŒæ³¨é‡Šã€å¤šè¡Œæ–‡æœ¬ï¼‰ï¼Œè¿˜åˆ©äº**å›¢é˜Ÿåä½œ**ï¼ˆå¤šäººå¼€å‘ä¸åŒçš„æ¨¡å—ï¼‰å’Œ**ç‰ˆæœ¬ç®¡ç†**ã€‚

æˆ‘ä»¬å°†é‡‡ç”¨ **"ä¸»æ¸…å• (Manifest) + ç»„ä»¶ (Components)"** çš„æ¶æ„ã€‚

### ğŸ“‚ 1. æ¨èçš„é¡¹ç›®æ–‡ä»¶ç»“æ„

```text
my_agent_project/
â”œâ”€â”€ agent.yaml                # [å…¥å£] ä¸»æ¸…å•æ–‡ä»¶ï¼Œå®šä¹‰å…ƒæ•°æ®å’Œå¼•ç”¨
â”œâ”€â”€ definitions/              # [å®šä¹‰å±‚]
â”‚   â”œâ”€â”€ types.yaml            # è‡ªå®šä¹‰ç±»å‹ (Enums, Pydantic Models)
â”‚   â””â”€â”€ signatures.yaml       # DSPy ç­¾åå®šä¹‰ (å¯æŒ‰ä¸šåŠ¡æ‹†åˆ†å¤šä¸ª)
â”œâ”€â”€ modules/                  # [ç»„ä»¶å±‚]
â”‚   â””â”€â”€ nodes.yaml            # èŠ‚ç‚¹/æ¨¡ç»„å®ä¾‹åŒ–é…ç½®
â””â”€â”€ graph/                    # [é€»è¾‘å±‚]
    â””â”€â”€ workflow.yaml         # æµé‡ã€åˆ†æ”¯ã€å¾ªç¯é€»è¾‘
```

---

### ğŸ“ 2. YAML æ–‡ä»¶å†…å®¹è¯¦è§£

#### 2.1 ä¸»æ¸…å•: `agent.yaml`
è¿™æ˜¯åŠ è½½å™¨çš„å…¥å£ï¼Œè´Ÿè´£æŠŠæ•£è½çš„ç§¯æœ¨æ‹¼èµ·æ¥ã€‚

```yaml
# agent.yaml
agent_id: customer_support_bot_v3
version: 3.0.0
description: >
  ä¼ä¸šçº§å®¢æˆ·æ”¯æŒ Agentï¼Œå…·å¤‡é•¿æ–‡æ¡£åˆ†å—æ‘˜è¦èƒ½åŠ›ï¼Œ
  å¹¶èƒ½æ ¹æ®ç”¨æˆ·æ„å›¾è‡ªåŠ¨è·¯ç”±è‡³ä¸åŒä¸“å®¶ã€‚

# é…ç½®å¼•ç”¨è·¯å¾„ (ç›¸å¯¹äºå½“å‰æ–‡ä»¶)
includes:
  types: "definitions/types.yaml"
  signatures: 
    - "definitions/signatures.yaml"
  nodes: 
    - "modules/nodes.yaml"
  flow: "graph/workflow.yaml"
```

#### 2.2 ç±»å‹å®šä¹‰: `definitions/types.yaml`
é›†ä¸­ç®¡ç†è‡ªå®šä¹‰ç±»å‹ï¼Œæ–¹ä¾¿åç»­ Signature å¤ç”¨ã€‚

```yaml
# definitions/types.yaml
types:
  UrgencyEnum: "Literal[1, 2, 3, 4, 5]"
  CategoryEnum: "Literal['Billing', 'Technical', 'General', 'Spam']"
  
  # å¦‚æœå°†æ¥æ”¯æŒ Pydantic Modelï¼Œå¯ä»¥åœ¨è¿™é‡Œå®šä¹‰ç»“æ„
  # CustomerInfo: ...
```

#### 2.3 ç­¾åå®šä¹‰: `definitions/signatures.yaml`
**æ ¸å¿ƒéƒ¨åˆ†**ã€‚YAML çš„ `|` è¯­æ³•éå¸¸é€‚åˆç¼–å†™å¤æ‚çš„ Docstringï¼ˆè¿™å¯¹ Prompt æ•ˆæœè‡³å…³é‡è¦ï¼‰ã€‚

```yaml
# definitions/signatures.yaml
signatures:
  RouterSignature:
    docstring: |
      You are a customer support manager. 
      Analyze the incoming query to determine the customer's intent and urgency.
      Please pay attention to the emotional tone of the user.
    inputs:
      user_query:
        desc: "The raw text message from a customer ticket"
        type: str
    outputs:
      intent:
        desc: "One of: Billing, Technical, General, Spam"
        type: CategoryEnum  # å¼•ç”¨ types.yaml ä¸­çš„å®šä¹‰
      urgency_score:
        desc: "Integer 1-5 (5 is highest urgency)"
        type: UrgencyEnum

  ChunkSummarizerSignature:
    docstring: |
      Summarize the given text chunk.
      Extract key information relevant to customer support issues like product bugs or refund requests.
    inputs:
      chunk_text:
        desc: "A segment of a larger document"
        type: str
    outputs:
      key_points:
        desc: "Concise bullet points of key information"
        type: str

  RefundSignature:
    docstring: "Handle refund requests based on company policy context."
    inputs:
      query:
        desc: "User's specific refund request"
      context:
        desc: "Relevant policy document summary extracted from knowledge base"
    outputs:
      response:
        desc: "A polite, policy-compliant response"
```

#### 2.4 èŠ‚ç‚¹é…ç½®: `modules/nodes.yaml`
å®ä¾‹åŒ– DSPy Moduleï¼Œå°† Signature å’Œ Module ç±»å‹ç»‘å®šã€‚

```yaml
# modules/nodes.yaml
nodes:
  # === å·¥å…·èŠ‚ç‚¹ ===
  splitter:
    type: Tool
    tool_name: text_splitter
    instruction: "Split long text into fixed-size chunks."

  # === DSPy æ¨¡å—èŠ‚ç‚¹ ===
  summarizer:
    type: ChainOfThought
    signature: ChunkSummarizerSignature  # å¼•ç”¨ signatures.yaml

  router:
    type: ChainOfThought
    signature: RouterSignature

  refund_expert:
    type: ChainOfThought
    signature: RefundSignature

  tech_expert:
    type: ChainOfThought
    # ä¹Ÿå¯ä»¥ç›´æ¥å†…è”å®šä¹‰ç®€å•ç­¾åï¼Œä¸ä¸€å®šè¦åœ¨ signatures.yaml é‡Œ
    signature: "query, context -> response"
    instruction: |
      You are a technical support expert. 
      Provide step-by-step troubleshooting based on the context.

  general_chat:
    type: Predict
    signature: "query -> response"
    instruction: "A helpful general assistant for small talk."
```

#### 2.5 æµç¨‹é€»è¾‘: `graph/workflow.yaml`
å®šä¹‰å›¾çš„æ‹“æ‰‘ç»“æ„ã€‚

```yaml
# graph/workflow.yaml
flow:
  start_node: splitter
  
  rules:
    # 1. é¢„å¤„ç†ï¼šåˆ†å—
    splitter:
      type: sequence
      next: summarizer_loop

    # 2. å¾ªç¯ï¼šMap Reduce å¤„ç†æ–‡æ¡£
    summarizer_loop:
      type: map
      source_list: chunks          # ä¸Šä¸€æ­¥ splitter äº§ç”Ÿçš„å˜é‡
      apply_node: summarizer       # å¾ªç¯è°ƒç”¨çš„èŠ‚ç‚¹
      output_var: document_summary # èšåˆåçš„å˜é‡å
      reduce_strategy: join_newline
      next: router

    # 3. è·¯ç”±ï¼šåˆ†æ”¯åˆ¤æ–­
    router:
      type: branch
      source_var: intent           # ç›‘å¬ router èŠ‚ç‚¹è¾“å‡ºçš„ intent å­—æ®µ
      branches:
        Billing: refund_expert
        Technical: tech_expert
      default: general_chat

    # 4. ç»ˆç»“èŠ‚ç‚¹
    refund_expert: 
      next: end
    tech_expert: 
      next: end
    general_chat: 
      next: end
```

---

### ğŸš€ 3. é…å¥—ä»£ç ï¼šYAML åŠ è½½å™¨ä¸åŠ¨æ€æ„å»º

æˆ‘ä»¬éœ€è¦å‡çº§ `engine.py`ï¼Œå¢åŠ ä¸€ä¸ª `DNALoader` ç±»æ¥å¤„ç† YAML æ–‡ä»¶çš„è¯»å–å’Œåˆå¹¶ã€‚

**å®‰è£…ä¾èµ–:**
```bash
pip install pyyaml
```

**å®Œæ•´çš„ `engine.py` (å« Loader):**

```python
import dspy
import yaml
import os
from typing import Dict, Any, Type, List

# ==========================================
# 1. DNA Loader (YAML åŠ è½½ä¸åˆå¹¶)
# ==========================================
class DNALoader:
    @staticmethod
    def load(entry_yaml_path: str) -> Dict[str, Any]:
        """
        åŠ è½½ä¸» YAML å¹¶é€’å½’åˆå¹¶æ‰€æœ‰å¼•ç”¨çš„å­æ–‡ä»¶ï¼Œè¿”å›å®Œæ•´çš„ Config Dict
        """
        base_dir = os.path.dirname(entry_yaml_path)
        
        with open(entry_yaml_path, 'r', encoding='utf-8') as f:
            main_config = yaml.safe_load(f)
        
        full_config = {
            "agent_id": main_config.get("agent_id"),
            "types": {},
            "signatures": {},
            "nodes": {},
            "flow": {}
        }

        # è¾…åŠ©å‡½æ•°ï¼šåŠ è½½æ–‡ä»¶å¹¶æ›´æ–°å­—å…¸
        def load_and_merge(section_name, relative_path):
            full_path = os.path.join(base_dir, relative_path)
            with open(full_path, 'r', encoding='utf-8') as f:
                content = yaml.safe_load(f)
                # å‡è®¾å­æ–‡ä»¶é‡Œç›´æ¥åŒ…å« section_name å¯¹åº”çš„ key (å¦‚ types.yaml é‡Œæœ‰ types: ...)
                # æˆ–è€…å­æ–‡ä»¶å°±æ˜¯çº¯å†…å®¹ï¼Œè¿™é‡Œæ ¹æ®ä¸Šé¢çš„ YAML ç»“æ„ï¼Œå­æ–‡ä»¶åŒ…å«æ ¹ key
                if content and section_name in content:
                    full_config[section_name].update(content[section_name])
                elif content and section_name == "flow": # flow é€šå¸¸åœ¨æ–‡ä»¶ä¸­æ˜¯æ ¹å¯¹è±¡
                    full_config["flow"] = content.get("flow", {})

        # 1. Load Types
        if "types" in main_config.get("includes", {}):
            load_and_merge("types", main_config["includes"]["types"])

        # 2. Load Signatures (æ”¯æŒåˆ—è¡¨)
        sig_paths = main_config.get("includes", {}).get("signatures", [])
        if isinstance(sig_paths, str): sig_paths = [sig_paths]
        for p in sig_paths:
            load_and_merge("signatures", p)

        # 3. Load Nodes (æ”¯æŒåˆ—è¡¨)
        node_paths = main_config.get("includes", {}).get("nodes", [])
        if isinstance(node_paths, str): node_paths = [node_paths]
        for p in node_paths:
            load_and_merge("nodes", p)

        # 4. Load Flow
        if "flow" in main_config.get("includes", {}):
            load_and_merge("flow", main_config["includes"]["flow"])

        return full_config

# ==========================================
# 2. åŠ¨æ€ç­¾åæ„å»º (å¤ç”¨ä¹‹å‰çš„é€»è¾‘)
# ==========================================
def create_dynamic_signature(name: str, sig_config: Dict, type_registry: Dict) -> Type[dspy.Signature]:
    class_attributes = {
        "__doc__": sig_config.get("docstring", "").strip()
    }

    # å¤„ç† Input
    for field_name, meta in sig_config.get("inputs", {}).items():
        # è¿™é‡Œç®€å•å¤„ç† descï¼Œå¦‚æœæœ‰ type å¯ä»¥åœ¨è¿™é‡Œåšæ‰©å±•æ ¡éªŒ
        class_attributes[field_name] = dspy.InputField(desc=meta.get("desc", ""))

    # å¤„ç† Output
    for field_name, meta in sig_config.get("outputs", {}).items():
        class_attributes[field_name] = dspy.OutputField(desc=meta.get("desc", ""))

    return type(name, (dspy.Signature,), class_attributes)

# ==========================================
# 3. Dynamic Bot Engine (æ”¯æŒ YAML ç»“æ„)
# ==========================================
class DynamicBot(dspy.Module):
    def __init__(self, entry_yaml_path: str):
        super().__init__()
        
        # === Step A: Load DNA from YAMLs ===
        print(f"ğŸ“‚ Loading Agent DNA from: {entry_yaml_path}")
        self.config = DNALoader.load(entry_yaml_path)
        
        # === Step B: Register Types (ç®€åŒ–ç‰ˆ) ===
        self.custom_types = self.config.get("types", {})
        
        # === Step C: Build Signatures ===
        self.sig_classes = {}
        for name, sig_cfg in self.config.get("signatures", {}).items():
            self.sig_classes[name] = create_dynamic_signature(name, sig_cfg, self.custom_types)
            
        # === Step D: Build Nodes ===
        self.flow_rules = self.config["flow"].get("rules", {})
        self.start_node = self.config["flow"].get("start_node")
        
        # å®ä¾‹åŒ–å·¥å…· (Mock)
        self.tools = {
            "text_splitter": lambda text: [text[i:i+50] for i in range(0, len(text), 50)] if text else []
        }

        for node_name, node_cfg in self.config["nodes"].items():
            node_type = node_cfg["type"]
            
            if node_type in ["ChainOfThought", "Predict", "ReAct"]:
                # è§£æ Signature
                sig_ref = node_cfg["signature"]
                if sig_ref in self.sig_classes:
                    signature = self.sig_classes[sig_ref]
                else:
                    # å†…è”å­—ç¬¦ä¸²ç­¾å
                    signature = dspy.Signature(sig_ref)
                    signature.__doc__ = node_cfg.get("instruction", "")
                
                # å®ä¾‹åŒ–
                if node_type == "ChainOfThought":
                    module = dspy.ChainOfThought(signature)
                elif node_type == "Predict":
                    module = dspy.Predict(signature)
                
                self.__setattr__(node_name, module)

    def forward(self, **kwargs):
        context = kwargs.copy()
        current = self.start_node
        
        print(f"\nğŸš€ Agent Started at [{current}]")
        
        while current != "end":
            rule = self.flow_rules.get(current, {"next": "end"})
            node_cfg = self.config["nodes"][current]
            print(f"Running Node: {current} ({node_cfg['type']})")
            
            # --- Node Execution Logic ---
            if node_cfg["type"] == "Tool":
                # Tool Logic
                tool_fn = self.tools.get(node_cfg["tool_name"])
                # ç®€å•æ˜ å°„ï¼šå‡è®¾å·¥å…·åªè¦ 'full_document_text'
                val = context.get("full_document_text", "")
                res = tool_fn(val)
                context["chunks"] = res # å‡è®¾ç¡¬ç¼–ç è¾“å‡ºç»™ chunks
                
            elif node_cfg["type"] in ["ChainOfThought", "Predict"]:
                # DSPy Logic
                module = getattr(self, current)
                try:
                    pred = module(**context)
                    # Merge context
                    for k, v in pred.items():
                        context[k] = v
                except Exception as e:
                    print(f"Error: {e}")
                    break

            # --- Flow Logic ---
            ftype = rule.get("type", "sequence")
            
            if ftype == "sequence":
                current = rule.get("next", "end")
                
            elif ftype == "map":
                # Loop logic (ç®€åŒ–æ¼”ç¤º)
                print(" -> Map Loop Triggered")
                current = rule.get("next", "end")
                
            elif ftype == "branch":
                src_val = str(context.get(rule["source_var"], "")).strip()
                print(f" -> Branching on '{src_val}'")
                # ç®€å•åŒ¹é…
                next_node = rule["default"]
                for k, v in rule["branches"].items():
                    if k in src_val:
                        next_node = v
                        break
                current = next_node
                
            else:
                current = "end"
                
        return dspy.Prediction(**context)

# ==========================================
# 4. ä½¿ç”¨ç¤ºä¾‹
# ==========================================
if __name__ == "__main__":
    # ç¡®ä¿ dspy é…ç½®äº† LM
    dspy.settings.configure(lm=dspy.DummyLM(["Intent: Technical"]))
    
    # ç›´æ¥ä¼ å…¥å…¥å£ yaml æ–‡ä»¶è·¯å¾„
    agent = DynamicBot("agent_dna/agent.yaml")
    
    # è¿è¡Œ
    agent(user_query="My computer is broken", full_document_text="Manual...")
```

### ğŸŒŸ ä¼˜åŠ¿æ€»ç»“

1.  **æ‰€è§å³æ‰€å¾— (WYSIWYG)**: ç¼–å†™ Signature æ—¶ï¼Œ`docstring` å¯ä»¥å†™å¾—éå¸¸è¯¦ç»†ï¼Œåƒå†™ Markdown æ–‡æ¡£ä¸€æ ·ï¼Œè¿™å¯¹ LLM ç†è§£æ„å›¾è‡³å…³é‡è¦ã€‚
2.  **å…³æ³¨ç‚¹åˆ†ç¦»**: 
    *   Prompt å·¥ç¨‹å¸ˆä¸“æ³¨ `signatures/*.yaml`ã€‚
    *   æ¶æ„å¸ˆä¸“æ³¨ `graph/workflow.yaml`ã€‚
    *   å¼€å‘è€…ä¸“æ³¨ `modules/nodes.yaml`ã€‚
3.  **å¯å¤ç”¨æ€§**: å®šä¹‰ä¸€æ¬¡ `types.yaml` æˆ– `signatures.yaml`ï¼Œå¯ä»¥åœ¨å¤šä¸ª Agent ä¸­è¢« `include`ã€‚
